/********************************************************************************
** Created by: Alex Levkovich (alevkovich@tut.by)
** License:    GPL
********************************************************************************/

/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp -v -c PacmanServerInterface -p pacmanserverinterface.h:pacmanserverinterface.cpp org.alexl.PacmanServer.xml
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef PACMANSERVERINTERFACE_H_1392976000
#define PACMANSERVERINTERFACE_H_1392976000

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>
#ifdef PACMANENTRY
#include "pacmanentry.h"
#endif

Q_DECLARE_METATYPE(QList<int>)

#include "dbuswatcher.h"

/*
 * Proxy class for interface org.alexl.PacmanDBusServer
 */
class PacmanServerInterface: public QDBusAbstractInterface {
    Q_OBJECT
public:
    static inline const char *name()
    { return "org.alexl.PacmanDBusServer"; }
    static inline const char *path()
    { return "/org/alexl/PacmanDBusServer"; }

public:
    ~PacmanServerInterface();

    static PacmanServerInterface * createInstance(QObject *parent = 0);
    static PacmanServerInterface * instance();
    static DBusWatcher * watcher();

protected:
    PacmanServerInterface(QObject *parent = 0);

private slots:
    void _start();

public Q_SLOTS: // METHODS
    inline QString commandRequest(const QByteArray &command) {
        QDBusReply<QString> reply = call(QLatin1String("commandRequest"), QVariant::fromValue(command));
        if (reply.isValid()) return reply.value();
        return reply.error().message();
    }

    inline void setDependance(bool doDeps) {
        call(QLatin1String("setDependance"), QVariant::fromValue(doDeps));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setFilePath(const QString &file_path) {
        call(QLatin1String("setFilePath"), QVariant::fromValue(file_path));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setUrl(const QUrl &url) {
        call(QLatin1String("setUrl"), QVariant::fromValue(url.toString()));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setPackageList(const QStringList &packages) {
        call(QLatin1String("setPackageList"), QVariant::fromValue(packages));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setPackages(const QString &packages) {
        call(QLatin1String("setPackages"), QVariant::fromValue(packages));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setPassword(const QByteArray &password) {
        call(QLatin1String("setPassword"), QVariant::fromValue(password));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void setSelectedProvider(const QString &provider) {
        call(QLatin1String("setSelectedProvider"), QVariant::fromValue(provider));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void terminateRequest(const QByteArray & command) {
        call(QLatin1String("terminateRequest"), QVariant::fromValue(command));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void beginInstall() {
        call(QLatin1String("beginInstall"));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void cancelInstall() {
        call(QLatin1String("cancelInstall"));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void beginRemove() {
        call(QLatin1String("beginRemove"));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void cancelRemove() {
        call(QLatin1String("cancelRemove"));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }

    inline void sendAnswer(int answer) {
        call(QLatin1String("sendAnswer"), QVariant::fromValue(answer));
        QDBusError err = lastError();
        if (err.isValid()) emit dbus_error(err.message());
    }


protected slots:
#ifdef PACMANENTRY
    void on_package_ready(const QByteArray & entry);
#endif
    void on_links_ready(const QByteArray & links);
    void on_dbus_loaded();
    void on_dbus_unloaded();

signals: // SIGNALS
    void command_finished(const QByteArray & command,const QString &errorMsg);
    void contents_length_found(int len);
    void download_progress(int percents);
    void start_download(const QString & url);
    void all_downloads_completed();
    void files_ready(const QString &package, const QStringList &files);
    void ready_to_process_install(const QStringList &install_packages, const QStringList &remove_packages, const QStringList &local_install_packages, qreal total_installed, qreal total_removed);
    void ready_to_process_remove(const QStringList &remove_packages, qreal total_removed);
    void packages_to_update(const QStringList &entry);
#ifdef PACMANENTRY
    void package_ready(const PacmanEntry &entry);
#endif
    void links_ready(const QList<QUrl> &links);
    void post_messages(const QString &package, const QStringList &messages);
    void salt_ready(const QByteArray &salt);
    void some_providers_available(const QStringList &providers);
    void question_available(const QString &question);
    void start_installing(const QString &name);
    void start_removing(const QString &name);
    void show_tray_window();
    void client_started();
    void client_exited();
    void dbus_error(const QString & msg);

private:
    static QObject * save_parent;
    static PacmanServerInterface * p_dbus_interface;
    static DBusWatcher * p_dbus_wacher;
};

namespace org {
  namespace alexl {
    typedef ::PacmanServerInterface PacmanDBusServer;
  }
}
#endif
