/********************************************************************************
** Created by: Alex Levkovich (alevkovich@tut.by)
** License:    GPL
********************************************************************************/

/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp -v -c PacmanServerInterface -p pacmanserverinterface.h:pacmanserverinterface.cpp org.alexl.PacmanServer.xml
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef PACMANSERVERINTERFACE_H_1392976000
#define PACMANSERVERINTERFACE_H_1392976000

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>
#ifdef PACMANENTRY
#include "pacmanentry.h"
#endif

Q_DECLARE_METATYPE(QList<int>)

#include "dbuswatcher.h"

/*
 * Proxy class for interface org.alexl.PacmanDBusServer
 */
class PacmanServerInterface: public QDBusAbstractInterface {
    Q_OBJECT
public:
    static inline const char *name()
    { return "org.alexl.PacmanDBusServer"; }
    static inline const char *path()
    { return "/org/alexl/PacmanDBusServer"; }

public:
    ~PacmanServerInterface();

    static PacmanServerInterface * createInstance(QObject *parent = 0);
    static PacmanServerInterface * instance();
    static DBusWatcher * watcher();

protected:
    PacmanServerInterface(QObject *parent = 0);

public Q_SLOTS: // METHODS
    inline QDBusPendingReply<QString> commandRequest(const QByteArray &command) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(command);
        return asyncCallWithArgumentList(QLatin1String("commandRequest"), argumentList);
    }

    inline QDBusPendingReply<> setDependance(bool doDeps) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(doDeps);
        return asyncCallWithArgumentList(QLatin1String("setDependance"), argumentList);
    }

    inline QDBusPendingReply<> setFilePath(const QString &file_path) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(file_path);
        return asyncCallWithArgumentList(QLatin1String("setFilePath"), argumentList);
    }

    inline QDBusPendingReply<> setUrl(const QUrl &url) {
        QList<QVariant> argumentList;
        QString str = url.toString();
        argumentList << QVariant::fromValue(url.toString());
        return asyncCallWithArgumentList(QLatin1String("setUrl"), argumentList);
    }

    inline QDBusPendingReply<> setPackageList(const QStringList &packages) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(packages);
        return asyncCallWithArgumentList(QLatin1String("setPackageList"), argumentList);
    }

    inline QDBusPendingReply<> setPackages(const QString &packages) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(packages);
        return asyncCallWithArgumentList(QLatin1String("setPackages"), argumentList);
    }

    inline QDBusPendingReply<> setPassword(const QByteArray &password) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(password);
        return asyncCallWithArgumentList(QLatin1String("setPassword"), argumentList);
    }

    inline QDBusPendingReply<> setSelectedProvider(const QString &provider) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(provider);
        return asyncCallWithArgumentList(QLatin1String("setSelectedProvider"), argumentList);
    }

    inline QDBusPendingReply<> terminateRequest(const QByteArray & command) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(command);
        return asyncCallWithArgumentList(QLatin1String("terminateRequest"), argumentList);
    }

    inline QDBusPendingReply<> beginInstall() {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("beginInstall"), argumentList);
    }

    inline QDBusPendingReply<> cancelInstall() {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("cancelInstall"), argumentList);
    }

    inline QDBusPendingReply<> beginRemove() {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("beginRemove"), argumentList);
    }

    inline QDBusPendingReply<> cancelRemove() {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("cancelRemove"), argumentList);
    }

    inline QDBusPendingReply<> sendAnswer(int answer) {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(answer);
        return asyncCallWithArgumentList(QLatin1String("sendAnswer"), argumentList);
    }

protected slots:
#ifdef PACMANENTRY
    void on_package_ready(const QByteArray & entry);
#endif
    void on_links_ready(const QByteArray & links);
    void on_dbus_loaded();
    void on_dbus_unloaded();

signals: // SIGNALS
    void command_finished(const QByteArray & command,const QString &errorMsg);
    void contents_length_found(int len);
    void download_progress(int percents);
    void start_download(const QString & url);
    void all_downloads_completed();
    void files_ready(const QString &package, const QStringList &files);
    void ready_to_process_install(const QStringList &install_packages, const QStringList &remove_packages, const QStringList &local_install_packages, qreal total_installed, qreal total_removed);
    void ready_to_process_remove(const QStringList &remove_packages, qreal total_removed);
    void packages_to_update(const QStringList &entry);
#ifdef PACMANENTRY
    void package_ready(const PacmanEntry &entry);
#endif
    void links_ready(const QList<QUrl> &links);
    void post_messages(const QString &package, const QStringList &messages);
    void salt_ready(const QByteArray &salt);
    void some_providers_available(const QStringList &providers);
    void question_available(const QString &question);
    void start_installing(const QString &name);
    void start_removing(const QString &name);
    void show_tray_window();
    void client_started();
    void client_exited();

private:
    static QObject * save_parent;
    static PacmanServerInterface * p_dbus_interface;
    static DBusWatcher * p_dbus_wacher;
};

namespace org {
  namespace alexl {
    typedef ::PacmanServerInterface PacmanDBusServer;
  }
}
#endif
